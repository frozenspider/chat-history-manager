syntax = "proto3";

package history;

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  package_name: "org.fs.chm.protobuf"
  flat_package: true
  single_file: true
  no_default_values_in_constructor: true
  enum_value_naming: CAMEL_CASE
  enum_strip_prefix: true
};

service HistoryParserService {
  // Parse a history file and return it entirely
  rpc Parse(ParseRequest) returns (ParseResponse) {}
}

message Empty {}

message ParseRequest {
  string path = 1;
}

message ParseResponse {
  Dataset ds = 1 [(scalapb.field).no_box = true];

  string root_file = 2;

  User myself = 3 [(scalapb.field).no_box = true];

  // Includes myself
  repeated User users = 4;

  repeated ChatWithMessages cwms = 5;
}

service ChooseMyselfService {
  rpc ChooseMyself(ChooseMyselfRequest) returns (ChooseMyselfResponse) {}
}

message ChooseMyselfRequest {
  repeated User users = 1;
}

message ChooseMyselfResponse {
  int32 picked_option = 1;
}

message Dataset {
  PbUuid uuid = 1 [(scalapb.field).no_box = true];
  string alias = 2;
}

message User {
  PbUuid ds_uuid = 1 [(scalapb.field).no_box = true];
  // Unique within a dataset.
  int64 id = 2;
  // If there's no first/last name separation, everything will be in first name.
  optional string first_name_option = 3;
  optional string last_name_option = 4;
  optional string username_option = 5;
  optional string phone_number_option = 6;
}

message ChatWithMessages {
  Chat chat = 1 [(scalapb.field).no_box = true];
  repeated Message messages = 2;
}

message PbUuid {
  // Should be lowercase!
  string value = 1;
}

// The request with a id of the book
message Chat {
  PbUuid ds_uuid = 1 [(scalapb.field).no_box = true];
  // Unique within a dataset
  int64 id = 2;

  // Can actually be none sometimes
  optional string name_option = 3;
  SourceType source_type = 8;
  ChatType tpe = 4;

  // Path relative to data root!
  optional string img_path_option = 5;

  // Always contains myself as the first element. The rest might be empty, e.g. if nobody ever wrote anything.
  // Members must be in some fixed order.
  repeated int64 member_ids = 6;
  int32 msg_count = 7;
}

enum SourceType {
  SOURCE_TYPE_TEXT_IMPORT = 0;
  SOURCE_TYPE_TELEGRAM = 1;
  SOURCE_TYPE_WHATSAPP_DB = 2;
  SOURCE_TYPE_TINDER_DB = 3;
}

enum ChatType {
  CHAT_TYPE_PERSONAL = 0;
  CHAT_TYPE_PRIVATE_GROUP = 1;
}

/*
 * Design goal for messages - try to reuse as many fields as possible to comfortably store
 * the whole Message hierarchy in one table.
 *
 * Same applies to Content.
 */

message Message {
  option (scalapb.message).no_box = true;  // do not wrap in Option

  /**
   * ID assigned to this message by a DAO storage engine (even local one), always valid and >= 0.
   * Within a chat, guaranteed to be unique and properly ordered.
   * Might change on dataset/chat mutation operations.
   * Should NEVER be compared across different DAOs!
   */
  int64 internal_id = 1;

  /**
   * Unique within a chat, serves as a persistent ID when merging with older/newer DB version.
   * If it's not useful for this purpose, should be empty.
   * No ordering guarantees are provided.
   */
  optional int64 source_id_option = 2;
  // Number of epoch SECONDS (not millis!)
  int64 timestamp = 3;
  int64 fromId = 4;

  repeated RichTextElement text = 5;

  // String that can be used to search this content.
  string searchable_string = 6;

  oneof typed {
    MessageRegular regular = 7;
    MessageService service = 8;
  }
}

message MessageRegular {
  // Number of epoch SECONDS (not millis!)
  optional int64 edit_timestamp_option = 1;
  // If true, edit timestamp refers to deletion time (if known)
  bool is_deleted = 5;
  optional string forward_from_name_option = 2;
  // References source ID
  optional int64 reply_to_message_id_option = 3;
  optional Content content_option = 4;
}

message MessageService {
  oneof sealed_value_optional {
    MessageServicePhoneCall             phone_call = 1;
    MessageServiceSuggestProfilePhoto   suggest_profile_photo = 13;
    MessageServicePinMessage            pin_message = 2;
    MessageServiceClearHistory          clear_history = 3;
    MessageServiceBlockUser             block_user = 15;
    MessageServiceGroupCreate           group_create = 4;
    MessageServiceGroupEditTitle        group_edit_title = 5;
    MessageServiceGroupEditPhoto        group_edit_photo = 6;
    MessageServiceGroupDeletePhoto      group_delete_photo = 12;
    MessageServiceGroupInviteMembers    group_invite_members = 7;
    MessageServiceGroupRemoveMembers    group_remove_members = 8;
    MessageServiceGroupMigrateFrom      group_migrate_from = 9;
    MessageServiceGroupMigrateTo        group_migrate_to = 10;
    MessageServiceGroupCall             group_call = 11; // TODO: Unite with PhoneCall

    // Removed: message_deleted = 14
  }
}

message RichTextElement {
  oneof val {
    RtePlain            plain = 1;
    RteBold             bold = 2;
    RteItalic           italic = 3;
    RteUnderline        underline = 4;
    RteStrikethrough    strikethrough = 5;
    RteLink             link = 6;
    RtePrefmtInline     prefmt_inline = 7;
    RtePrefmtBlock      prefmt_block = 8;
    RteBlockquote       blockquote = 11;
    RteSpoiler          spoiler = 10;
  }

  // String that can be used to search this content.
  string searchable_string = 9;
}

message RtePlain {
  string text = 1;
}
message RteBold {
  string text = 1;
}
message RteItalic {
  string text = 1;
}
message RteUnderline {
  string text = 1;
}
message RteStrikethrough {
  string text = 1;
}
message RteLink {
  // Empty text would mean that this link is hidden - but it can still be hidden even if it's not.
  optional string text_option = 1;
  string href = 2;
  // Some TG chats use text_links with empty/invisible text to be shown as preview but not appear in text.
  bool hidden = 3;
}
message RtePrefmtInline {
  string text = 1;
}
message RtePrefmtBlock {
  string text = 1;
  optional string language_option = 2;
}
message RteSpoiler {
  string text = 1;
}
message RteBlockquote {
  string text = 1;
}

//
// Content
//

message Content {
  oneof sealed_value_optional {
    ContentSticker          sticker = 1;
    ContentPhoto            photo = 2;
    ContentVoiceMsg         voice_msg = 3;
    ContentAudio            audio = 10;
    ContentVideoMsg         video_msg = 4;
    ContentVideo            video = 5;
    ContentFile             file = 6;
    ContentLocation         location = 7;
    ContentPoll             poll = 8;
    ContentSharedContact    shared_contact = 9;
  }
}

message ContentSticker {
  // Path relative to data root!
  optional string path_option = 1;
  // 0 if unknown
  int32 width = 2;
  // 0 if unknown
  int32 height = 3;

  // Path relative to data root!
  optional string thumbnail_path_option = 4;
  optional string emoji_option = 5;
}

message ContentPhoto {
  // Path relative to data root!
  optional string path_option = 1;
  // 0 if unknown
  int32 width = 2;
  // 0 if unknown
  int32 height = 3;
  bool is_one_time = 4;
}

message ContentVoiceMsg {
  // Path relative to data root!
  optional string path_option = 1;
  string mime_type = 2;
  optional int32 duration_sec_option = 3;
}

message ContentAudio {
  // Path relative to data root!
  optional string path_option = 1;

  optional string title_option = 2;
  optional string performer_option = 3;

  string mime_type = 4;
  optional int32 duration_sec_option = 5;

  // Some audio files might have thumbnails - e.g. album cover
  // Path relative to data root!
  optional string thumbnail_path_option = 6;
}

message ContentVideoMsg {
  // Path relative to data root!
  optional string path_option = 1;
  // 0 if unknown
  int32 width = 2;
  // 0 if unknown
  int32 height = 3;

  string mime_type = 4;
  optional int32 duration_sec_option = 5;

  // Path relative to data root!
  optional string thumbnail_path_option = 6;

  bool is_one_time = 7;
}

message ContentVideo {
  // Path relative to data root!
  optional string path_option = 1;

  optional string title_option = 8;
  optional string performer_option = 9;

  // 0 if unknown
  int32 width = 2;
  // 0 if unknown
  int32 height = 3;

  string mime_type = 4;
  optional int32 duration_sec_option = 5;

  // Path relative to data root!
  optional string thumbnail_path_option = 6;

  bool is_one_time = 7;
}

message ContentFile {
  // Path relative to data root!
  optional string path_option = 1;
  optional string file_name_option = 2;

  optional string mime_type_option = 5;

  // Path relative to data root!
  optional string thumbnail_path_option = 7;
  // Removed: width_option = 3, height_option = 4, duration_sec_option = 6, performer_option = 8
}

message ContentLocation {
  optional string title_option = 1;
  optional string address_option = 2;
  string lat_str = 3;
  string lon_str = 4;

  optional int32 duration_sec_option = 5;
}

message ContentPoll {
  string question = 1;
}

// At least ONE of the fields must be present.
message ContentSharedContact {
  optional string first_name_option = 1;
  optional string last_name_option = 2;
  // Could hold multiple phone numbers separated by comma
  optional string phone_number_option = 3;
  // Path relative to data root!
  optional string vcard_path_option = 4;
}

//
// MessageService
//

message MessageServicePhoneCall {
  optional int32 duration_sec_option = 1;
  optional string discard_reason_option = 2;
}

message MessageServiceSuggestProfilePhoto {
  ContentPhoto photo = 1 [(scalapb.field).no_box = true];
}

message MessageServicePinMessage {
  int64 message_id = 1;
}

// Note: for Telegram, `from...` is not always meaningful
message MessageServiceClearHistory {}

message MessageServiceBlockUser {
  bool is_blocked = 1;
}

message MessageServiceGroupCreate {
  string title = 1;
  repeated string members = 2;
}

message MessageServiceGroupEditTitle {
  string title = 1;
}

message MessageServiceGroupEditPhoto {
  ContentPhoto photo = 1 [(scalapb.field).no_box = true];
}

message MessageServiceGroupDeletePhoto {}

message MessageServiceGroupInviteMembers {
  repeated string members = 1;
}

message MessageServiceGroupRemoveMembers {
  repeated string members = 1;
}

message MessageServiceGroupMigrateFrom {
  string title = 1;
}

// Migrate to supergroup of the same name
message MessageServiceGroupMigrateTo {}

// This is different to PhoneCall
message MessageServiceGroupCall {
  repeated string members = 1;
}

//
// HistoryLoaderService
//

service HistoryLoaderService {
  // Parse/open a history file and return its DAO handle
  rpc Load(LoadRequest) returns (LoadResponse) {}
  rpc GetLoadedFiles(Empty) returns (GetLoadedFilesResponse) {}
  rpc Close(CloseRequest) returns (CloseResponse) {}
}

service HistoryDaoService {
  rpc SaveAs(SaveAsRequest) returns (LoadedFile) {}
  rpc Name(NameRequest) returns (NameResponse) {}
  rpc StoragePath(StoragePathRequest) returns (StoragePathResponse) {}
  rpc Datasets(DatasetsRequest) returns (DatasetsResponse) {}
  rpc DatasetRoot(DatasetRootRequest) returns (DatasetRootResponse) {}
  rpc Myself(MyselfRequest) returns (MyselfResponse) {}
  rpc Users(UsersRequest) returns (UsersResponse) {}
  rpc Chats(ChatsRequest) returns (ChatsResponse) {}
  rpc ScrollMessages(ScrollMessagesRequest) returns (MessagesResponse) {}
  rpc LastMessages(LastMessagesRequest) returns (MessagesResponse) {}
  // Return N messages before the given one (exclusive). Message must be present.
  rpc MessagesBefore(MessagesBeforeRequest) returns (MessagesResponse) {}
  // Return N messages after the given one (exclusive). Message must be present.
  rpc MessagesAfter(MessagesAfterRequest) returns (MessagesResponse) {}
  // Return N messages between the given ones (inclusive). Messages must be present.
  rpc MessagesSlice(MessagesSliceRequest) returns (MessagesResponse) {}
  // Count messages between the given ones (inclusive). Messages must be present.
  rpc MessagesSliceLen(MessagesSliceRequest) returns (CountMessagesResponse) {}
  rpc MessageOption(MessageOptionRequest) returns (MessageOptionResponse) {}
  rpc MessageOptionByInternalId(MessageOptionByInternalIdRequest) returns (MessageOptionResponse) {}
  // Whether given data path is the one loaded in this DAO.
  rpc IsLoaded(IsLoadedRequest) returns (IsLoadedResponse) {}

  //
  // Mutable DAO endpoints
  //

  rpc Backup(BackupRequest) returns (Empty) {}
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse) {}
}

message LoadRequest {
  string key = 1;
  string path = 2;
}
message LoadResponse {
  string name = 1;
}

message GetLoadedFilesResponse {
  repeated LoadedFile files = 1;
}

message LoadedFile {
  string key = 1;
  string name = 2;
}

message SaveAsRequest {
  string key = 1;
  string new_folder_name = 2;
}

message NameRequest {
  string key = 1;
}
message NameResponse {
  string name = 1;
}

message StoragePathRequest {
  string key = 1;
}
message StoragePathResponse {
  string path = 1;
}

message DatasetsRequest {
  string key = 1;
}
message DatasetsResponse {
  repeated Dataset datasets = 1;
}

message DatasetRootRequest {
  string key = 1;
  PbUuid ds_uuid = 2 [(scalapb.field).no_box = true];
}
message DatasetRootResponse {
  string path = 1;
}

message MyselfRequest {
  string key = 1;
  PbUuid ds_uuid = 2 [(scalapb.field).no_box = true];
}
message MyselfResponse {
  User myself = 1 [(scalapb.field).no_box = true];
}

message UsersRequest {
  string key = 1;
  PbUuid ds_uuid = 2 [(scalapb.field).no_box = true];
}
message UsersResponse {
  repeated User users = 1;
}

message ChatsRequest {
  string key = 1;
  PbUuid ds_uuid = 2 [(scalapb.field).no_box = true];
}
message ChatsResponse {
  repeated ChatWithDetailsPB cwds = 1;
}
message ChatWithDetailsPB {
  Chat chat = 1 [(scalapb.field).no_box = true];

  optional Message last_msg_option = 2 [(scalapb.field).no_box = false];

  // First element MUST be myself, the rest should be in some fixed order.
  repeated User members = 3;
}

message ScrollMessagesRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 offset = 3;
  int64 limit = 4;
}
message LastMessagesRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 limit = 3;
}
message MessagesBeforeRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 message_internal_id = 3;
  int64 limit = 4;
}
message MessagesAfterRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 message_internal_id = 3;
  int64 limit = 4;
}
message MessagesSliceRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 message_internal_id_1 = 3;
  int64 message_internal_id_2 = 4;
}

message MessagesResponse {
  repeated Message messages = 1;
}
message CountMessagesResponse {
  int32 messages_count = 1;
}

message MessageOptionRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 source_id = 3;
}
message MessageOptionByInternalIdRequest {
  string key = 1;
  Chat chat = 2 [(scalapb.field).no_box = true];
  int64 internal_id = 3;
}
message MessageOptionResponse {
  optional Message message = 1 [(scalapb.field).no_box = false];
}

message IsLoadedRequest {
  string key = 1;
  string storage_path = 2;
}
message IsLoadedResponse {
  bool is_loaded = 1;
}

message CloseRequest {
  string key = 1;
}
message CloseResponse {
  bool success = 1;
}

message BackupRequest {
  string key = 1;
}

message UpdateUserRequest {
  string key = 1;
  User user = 2 [(scalapb.field).no_box = true];
}
message UpdateUserResponse {
  User user = 1 [(scalapb.field).no_box = true];
}

//
// MergeService
//

service MergeService {
  rpc Analyze(AnalyzeRequest) returns (AnalyzeResponse) {}
  rpc Merge(MergeRequest) returns (MergeResponse) {}

  // Temporary endpoint that helps to ensure new merging does the same the old merging does
  rpc Compare(CompareRequest) returns (CompareResponse) {}
}

message AnalyzeRequest {
  string master_dao_key = 1;
  PbUuid master_ds_uuid = 2 [(scalapb.field).no_box = true];

  string slave_dao_key = 3;
  PbUuid slave_ds_uuid = 4 [(scalapb.field).no_box = true];

  repeated int64 chat_ids = 5;
}
message AnalyzeResponse {
  repeated ChatAnalysis analysis = 1;
}
message ChatAnalysis {
  int64 chat_id = 1;
  repeated AnalysisSection sections = 2;
}
// This has internal IDs, those not corresponding to the type are unused
message AnalysisSection {
  AnalysisSectionType tpe = 1;
  MessageMergeSectionRange range = 2 [(scalapb.field).no_box = true];
}
enum AnalysisSectionType {
  ANALYSIS_SECTION_TYPE_MATCH = 0;
  ANALYSIS_SECTION_TYPE_RETENTION = 1;
  ANALYSIS_SECTION_TYPE_ADDITION = 2;
  ANALYSIS_SECTION_TYPE_CONFLICT = 3;
}
message MessageMergeSectionRange {
  int64 first_master_msg_id = 1;
  int64 last_master_msg_id = 2;
  int64 first_slave_msg_id = 3;
  int64 last_slave_msg_id = 4;
}

message MergeRequest {
  string master_dao_key = 1;
  PbUuid master_ds_uuid = 2 [(scalapb.field).no_box = true];

  string slave_dao_key = 3;
  PbUuid slave_ds_uuid = 4 [(scalapb.field).no_box = true];

  string new_database_dir = 5;

  repeated UserMerge user_merges = 6;
  repeated ChatMerge chat_merges = 7;
}
message UserMerge {
  UserMergeType tpe = 1;
  int64 user_id = 2;
}
enum UserMergeType {
  // Only in master
  USER_MERGE_TYPE_RETAIN = 0;

  // Only in slave, add
  USER_MERGE_TYPE_ADD = 1;
  // Only in slave, do not add
  USER_MERGE_TYPE_DONT_ADD = 2;

  // Conflicts between master and slave, use slave
  USER_MERGE_TYPE_REPLACE = 3;
  // Conflicts between master and slave - or they match, use master either way
  USER_MERGE_TYPE_MATCH_OR_DONT_REPLACE = 4;
}
message ChatMerge {
  ChatMergeType tpe = 1;
  int64 chat_id = 2;
  repeated MessageMerge message_merges = 3;
}
enum ChatMergeType{
  // Only in master
  CHAT_MERGE_TYPE_RETAIN = 0;
  // Only in slave, add
  CHAT_MERGE_TYPE_ADD = 1;
  // Only in slave, do not add
  CHAT_MERGE_TYPE_DONT_ADD = 2;
  // Exists in both, act according to message merge decisions
  CHAT_MERGE_TYPE_MERGE = 3;
}
message MessageMerge {
  MessageMergeType tpe = 1;
  MessageMergeSectionRange range = 2;
}
enum MessageMergeType {
  // Same in master and slave
  MESSAGE_MERGE_TYPE_MATCH = 0;

  // Only in master
  MESSAGE_MERGE_TYPE_RETAIN = 1;

  // Only in slave, add
  MESSAGE_MERGE_TYPE_ADD = 2;
  // Only in slave, do not add
  MESSAGE_MERGE_TYPE_DONT_ADD = 3;

  // Conflicts between master and slave, use slave
  MESSAGE_MERGE_TYPE_REPLACE = 4;
  // Conflicts between master and slave, use master
  MESSAGE_MERGE_TYPE_DONT_REPLACE = 5;
}
message MergeResponse {
  LoadedFile new_file = 1 [(scalapb.field).no_box = true];
  PbUuid new_ds_uuid = 2 [(scalapb.field).no_box = true];
}

message CompareRequest {
  string master_dao_key = 1;
  PbUuid master_ds_uuid = 2 [(scalapb.field).no_box = true];

  string slave_dao_key = 3;
  PbUuid slave_ds_uuid = 4 [(scalapb.field).no_box = true];
}
message CompareResponse {
}
